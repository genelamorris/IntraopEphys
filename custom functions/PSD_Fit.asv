%function [final_fit, aperiodic_A, aperiodic_C, Peak_freq, Peak_bw] = PSD_Fit(data_vec, f, peak_distance_Hz, min_peak_height_STD, plotting)
% PSD_Fit.m Fits a power-law model to the power spectral density (PSD) data and performs data cleaning.
% Roni Naivelt | May 2024.
% INPUTS:
%   data_vec: 1D array, input data vector containing power spectral density values.
%   f: 1D array, frequency vector corresponding to data_vec.
%   freq_clean_range: 1x2 array, frequency range (in Hz) to focus on during peak cleaning. Default: [4 30].
%   clean_window: Scalar, window size (in Hz) around each peak for cleaning. Default: 2.5.
%   clean_thresh: Scalar, threshold multiplier for peak cleaning. Default: 1.25.
%   plotting: Logical, specifies whether to plot the results. Default: false.

% OUTPUTS:
  % C: Scalar, coefficient of the fitted power-law model.
  % A: Scalar, exponent of the fitted power-law model.
  % Curve_vec: 1D array, fitted power-law curve based on the model.
  % Delta_vec: 1D array, difference between original data and the fitted curve.

%% function handling
if nargin < 6
    plotting = false;  % Default value for plotting
end

if nargin < 5
    clean_thresh = 1.25;  % Default value for clean_thresh
end

if nargin < 4
    clean_window = 2.5;  % Default value for clean_window
end

if nargin < 3
    freq_clean_range = [4 60];  % Default value for freq_clean_range
end

%% Initializing
data_vec = DataStruct_A.EC.table_EC_left.Alpha_Central{75,1}.PSD_vec;
f = DataStruct_A.EC.table_EC_left.Alpha_Central{75,1}.f_PSD;

% Initialize arrays to store peak centers, widths, and Gaussian parameters
peak_distance_Hz = 2.5;
min_peak_height_STD = 1;
peak_centers = [];
peak_widths = [];
gaussian_params = {};
gaussian_region = {};

% Function for Gaussian fitting
gauss_eq = @(a, b, c, x) a * exp(-((x - b).^2) / (2 * c^2));
% function for log fit
powerLawModel = fittype('(C / (f^A))', 'independent', 'f', 'coefficients', {'C', 'A'});

% adjusting frequency and data vectors
f = double(f);
data_vec = double(data_vec);

if find(f==0)                % check for f=0
    zero_indx = find(f==0);
    f = f(zero_indx+1:end);
    data_vec = data_vec(zero_indx+1:end);
end

if size(f,1) ~= 1            % check frequency input size
    f = f';
end

if size(data_vec,1) ~= 1     % check data input size
    data_vec = data_vec';
end

%% Step 1: fit and remove aperiodic fit
[fit_result,gof] = fit(f',data_vec',powerLawModel,...
                       'StartPoint',[1, 1],... %  StartPoint = Initial guess for [C, A, B]
                       'Lower',[0,0], ...      % Lower bounds for [C, A, B]
                       'Upper',[max(f), inf]);    % Upper bounds for [C, A, B]

% Extract fitted parameters
C = fit_result.C;
A = fit_result.A;
% B = fit_result.B;
aperiodic_fit = (C ./ (f.^A));
periodic_vec = data_vec - aperiodic_fit;

% Trim start if needed (sometimes the start is lower):
trim_thresh = mean(periodic_vec) - std(periodic_vec);
trim_indx = 1;
while periodic_vec(trim_indx) < trim_thresh
    trim_indx = trim_indx + 1;
end
f = f(trim_indx:end);
periodic_vec = periodic_vec(trim_indx:end);
aperiodic_fit = aperiodic_fit(trim_indx:end);
data_vec = data_vec(trim_indx:end);

% figure()
% plot(f,data_vec)
% hold on
% plot(f,aperiodic_fit)
% plot(f,periodic_vec)
% legend('original', 'aperiodic fit', 'periodic')

%% Step 2: fit a gaussian, find peaks and width

% Step 2.1: Find peaks higher than 1 standard deviation
std_dev = mean(periodic_vec) + min_peak_height_STD*std(periodic_vec);
[pks, locs] = findpeaks(periodic_vec, 'MinPeakHeight', std_dev, 'MinPeakDistance',peak_distance_Hz/(f(2)-f(1)));

local_mean  = movmean(periodic_vec, 5/mean(diff(f)));
local_std = movstd(periodic_vec,  5/mean(diff(f)));

% Step 2.2: Fit Gaussian and subtract from original signal
final_vec = periodic_vec;
for i = 1:length(pks)
    % Define dynamic region around the peak
    peak_center = locs(i);
    left_bound = peak_center;
    right_bound = peak_center;
    
    % Find left bound
    while left_bound > 1 &&...
        periodic_vec(left_bound) > local_mean(peak_center) +0.2*local_std(peak_center)
        if i > 1
            if left_bound == gaussian_region{i-1}(end)+1
                break;
            end
        end
        left_bound = left_bound - 1;
    end
    
    % Find right bound
    while right_bound < length(periodic_vec) &&...
            periodic_vec(right_bound) > local_mean(peak_center) +0.2*local_std(peak_center)
        right_bound = right_bound + 1;
    end
    
    % Define the region
    region = left_bound:right_bound;
    
    % Fit Gaussian to the region
    x_data = region';
    y_data = periodic_vec(region)';
    
    % Initial guess for parameters [amplitude, mean, stddev]
    init_guess = [pks(i), peak_center, 1];
    
    % Fit the Gaussian
    gauss_fit = fit(x_data, y_data, gauss_eq, 'StartPoint', init_guess);
    
    % Save peak center, width (stddev), and Gaussian parameters
    
    peak_centers = [peak_centers; gauss_fit.b];
    peak_widths = [peak_widths; gauss_fit.c];
    gaussian_params{i} = coeffvalues(gauss_fit);
    gaussian_region{i} = region;

    % Subtract Gaussian from the signal
    fitted_gaussian = gauss_eq(gauss_fit.a, gauss_fit.b, gauss_fit.c, x_data);
    final_vec(region) = final_vec(region) - fitted_gaussian';
end


% % Plot the original graph, the final graph, and all Gaussians
figure;
hold on;

% Plot original vector
plot(periodic_vec, 'Color', [1 0.5 0], 'DisplayName', 'Original Signal');

% plot noise threshold
yline(mean(periodic_vec) + std(periodic_vec), 'LineWidth', 1.5, 'DisplayName', 'Noise Threshold');

% Plot final vector
plot(final_vec, 'Color', [0 0 1], 'LineWidth', 2, 'DisplayName', 'Final Signal after Subtraction');

% Plot each fitted Gaussian
for i = 1:length(gaussian_params)
    gauss_fit = gaussian_params{i};
    x_data = gaussian_region{i};
    fitted_gaussian = gauss_eq(gauss_fit(1), gauss_fit(2), gauss_fit(3), x_data);
    plot(x_data, fitted_gaussian, '--', 'DisplayName', sprintf('Gaussian Fit %d', i));
end

legend;
title('Original Signal, Final Signal, and Gaussian Fits');
xlabel('Sample Index');
ylabel('Amplitude');
grid on;
hold off;


%% Step 3: Remove peaks from original vector and fit again
% Subtract Gaussian from the signal
data_vec_flattened = data_vec;
for i = 1:length(gaussian_params)
    gauss_fit = gaussian_params{i};
    region = gaussian_region{i};
    fitted_gaussian = gauss_eq(gauss_fit(1), gauss_fit(2), gauss_fit(3), region);
    data_vec_flattened(region) = data_vec_flattened(region) - fitted_gaussian;
end

% make the fit again
[fit_result,gof] = fit(f',data_vec_flattened',powerLawModel,...
                       'StartPoint',[1, 1],... %  StartPoint = Initial guess for [C, A, B]
                       'Lower',[0,0], ...      % Lower bounds for [C, A, B]
                       'Upper',[max(f), inf]);    % Upper bounds for [C, A, B]

% Extract fitted parameters
C = fit_result.C;
A = fit_result.A;
% B = fit_result.B;
flattened_aperiodic_fit = (C ./ (f.^A));
flatenned_periodic_vec = data_vec_flattened - flattened_aperiodic_fit;

final_fit = flattened_aperiodic_fit;
for i = 1:length(gaussian_params)
    gauss_fit = gaussian_params{i};
    region = gaussian_region{i};
    fitted_gaussian = gauss_eq(gauss_fit(1), gauss_fit(2), gauss_fit(3), region);
    final_fit(region) = final_fit(region) + fitted_gaussian;
end

if plotting
    figure()
    plot(f, data_vec, 'DisplayName', 'original')
    hold on
    plot(f,data_vec_flattened, 'DisplayName', 'flattened')
    plot(f,flattened_aperiodic_fit, 'DisplayName', 'aperiodic')
    % plot(f,flatenned_periodic_vec, 'DisplayName', 'periodic')
    plot(f,final_fit, 'LineWidth', 1.5, 'DisplayName', 'final fit')
end

%% step 4: save parameters
% aperiodic parameters
% C = offset coeffitiant of the logarithmic fit (C/f^A)
% A = exponent of the logirithmic fit (C/f^A)
aperiodic_A = A;
aperiodic_C = C;

% gaussians
Peak_freq = [];
for i = 1:length(peak_centers)
    Peak_freq = [Peak_freq f(round(peak_centers(i)))];
end

Peak_bw = [];
for i = 1:length(gaussian_region)
    region = gaussian_region{i};
    f_range = f(region(end))-f(region(1));
    Peak_bw = [Peak_bw f_range];
end

%% smoothen peaks
% f = double(f);
% data_vec = double(data_vec);
% df = f(2) - f(1);
% window_in_bins = floor(clean_window/df);
% clean_again = 1;
% smoothed_data_vec = data_vec;
% 
% while clean_again
%     clean_again = 0;
%     find peaks in the Power spectrum
%     [pks,locs] = findpeaks(smoothed_data_vec);
% 
%     Find the indices corresponding to the specified frequency range
%     locs_in_range = locs(locs > freq_clean_range(1) & locs < freq_clean_range(2));
%     pks_in_range = pks(locs > freq_clean_range(1) & locs < freq_clean_range(2));
%     smoothed_data_vec(Idx_min:Idx_max) = hampel(data_arround_peak);
% 
%     for i = 1:numel(locs_in_range)
%         Idx_min = max([locs_in_range(i)-window_in_bins 1]);
%         Idx_max = min([locs_in_range(i)+window_in_bins length(smoothed_data_vec)]);
%         data_arround_peak = smoothed_data_vec(Idx_min:Idx_max);
%         local_mean = median(data_arround_peak);
%         if pks_in_range(i) >= clean_thresh*local_mean
%             smoothed_data_vec(locs_in_range(i)) = local_mean;
%             clean_again = 1;
%         end
%     end
% end
% 
% % Fit curve
% Define the power-law model function
% powerLawModel = fittype('(C / (f^A)) + B', 'independent', 'f', 'coefficients', {'C', 'A', 'B'});
% [fit_result,gof] = fit(f',smoothed_data_vec',powerLawModel,...
%                        'StartPoint',[1, 1, 1],... %  StartPoint = Initial guess for [C, A]
%                        'Lower',[0,0, 0], ...      % Lower bounds for [C, A]
%                        'Upper',[max(f), inf, min(data_vec)]);    % Upper bounds for [C, A]
% 
% Extract fitted parameters
% C = fit_result.C;
% A = fit_result.A;
% B = fit_result.B;
% Curve_vec = (C ./ (f.^A)) + B;
% Delta_vec = data_vec - Curve_vec;


%% Plot
% if plotting
%     % Plot the original data and the fitted curve
%     figure;
%     plot(f, data_vec, 'DisplayName', 'Original Data', 'LineWidth',1);
%     hold on;
%     plot(f, smoothed_data_vec, 'DisplayName', 'smoothed Data', 'LineWidth',1);
%     plot(f, Curve_vec, 'r-', 'DisplayName', 'Fitted Curve', 'LineWidth',2.5);
%     plot(f, Delta_vec, '--', 'DisplayName', 'Delta Curve', 'LineWidth',2.5);
%     xlabel('Frequency (f)');
%     ylabel('Power Spectral Density (PSD)');
%     title('Power-Law Fit to PSD');
%     legend('show', 'FontSize', 14);
%     box off
%     set(gcf, 'Color','w')
% end
